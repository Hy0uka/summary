﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿#第一个汇编程序  1.伪指令，伪指令无法被编译成机器指令被CPU执行，由编译器执行。segments和ends是一对成对使用的伪指令，这是在写可被编译的汇编程序时必须要用到的伪指令。segment和ends的功能是定义一个段，segment说明一个段的开始，ends说明一个段的结束。  2.段的使用格式：  段名 segment          ：  段名 ends  3.一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或者被当作栈空间。一个源程序中，所有将被计算机所处理的信息即指令，数据，栈被划分到不同的段。  4.ends与segments配对使用，分别表示段的开始与结束。end与ends是两个不同的概念，end是整个程序的结束。  5.assume指令，将有特定用途的段与相关的段寄存器联系起来。比如用assume指令将代码段与CS联系起来。  6.源程序：源程序文件当中的所有内容。  程序：源程序中最终由计算机处理的指令或者数据。  7.与C语言类似，汇编中除了汇编指令，伪指令外，还有标号（段名）会在被编译的时候，转变为内存地址。  8.程序返回：一段汇编指令被编译成机器码储存在可执行文件中，要想运行必须载入内存。在dos单个任务操作系统上，必须先有正在运行的程序P1，将CPU的控制权交给P2后，P2才得以运行。所以一个程序结束运行后，必须将CPU控制权交给下一个程序，这个交换的过程成为程序返回。代码：  mov ax，4c00H  int 21H  9.源程序在编译的过程中被发现的错误称之为语法错误，编译完成后执行时发生的错误为逻辑错误。  10.asm，汇编源程序的扩展名。  11.源程序被编译后，可以得到obj（目标文件）/lst（列表文件）/crf（交叉引用文件）  12.![](https://github.com/Hy0uka/Warehouse/blob/master/TIM%E5%9B%BE%E7%89%8720190331.png?raw=true)  13.要完整地描述一个内存单元，需要两种信息。一是内存单元地地址，二是内存单元存储的长度（数据类型）。  用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认存储在ds中，单元的长度类型可以由具体指令中的其他操作对象比如寄存器指出。类似的，[bx]也表示一个内存单元，其偏移地址在bx中。  14.（bx）表示bx中的内容。   （）中可以有三种类型，寄存器名，段寄存器名，内存单元的物理地址。  由此可知，（X）中的数据类型有两种，字或者字节。15.注意push与pop指令对sp操作的先后顺序。  16.[idata]，表示数据17.mov ax，[bx]表示把bx中存放的数据作为一个偏移地址EA,段地址SA默认在ds中，将SA:EA处的数据送入ax中。  mov [bx],ax表示把bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。  18.inc表示自增。  19.cx与loop指令直接关联，存放循环的次数。  20.cx的使用：  mov ax，2   mov cx，11  s：add ax，ax  loop s  可计算2的12次方  21.在汇编语言中，标号代表一个地址，此程序中有一个标号（可以是任意字母），用来标识一个地址，这个地址处的指令就是所要循环的指令。  22.能否将ffff：0~ffff：b中的数据直接累加到dx中？  不能，直接的累加对位数有要求，相同位数的才能够直接相加。解决办法：将ax中的al和ah拆分开来用。  23.出现在访问内存单元的指令中，用于显式地知名内存单元的段地址的ds，cs，ss，es，在汇编语言中称为段前缀。使用段前缀可以在某些情况下减少代码的行数。    24.在不能确定一段内存空间中是否存放着重要的数据或者代码的时候，不能随意 向其中写入内容。Dos方式下，一般情况，0：200·0：2ff空间中没有系统或者其他程序的数据或者代码。  25.lea, load effective address, 加载有效地址. 指令形式是从存储器读数据到寄存器, 效果是将存储器的有效地址写入到目的操作数, 简单说, 就是C语言中的”&”.  26.movs/movsb/movsw/movsd edi,esi  这些变体以串/字节/字/双字为单位，将esi的值赋给edi。  27.movsx符号位扩展，byte->word，word-->dword（扩展后高位全用符号位填充），然后实现mov。    28.movzx零扩展，byte->word，word->dword（扩展后高位全部用零填充），然后实现mov。  29.CMP指令根据比较两个操作数的结果设置C/O/Z标志位。若两个寄存器中的值相等，则Z标志位置1，否则置零。也可以直接用[地址]与寄存器进行比较。  30.逆向工程中常用的三个标志位，C/O/Z，C为进位标志，记录运算时从最高有效位产生的进位值。执行加法运算时，最高有效位有进位时置1，否则置0.O标志位，溢出标志，在运行过程中，如果操作数超出了机器能表示的范围则称为溢出，溢出置1，未溢出置0.Z标志位最常用，运算结果为0时，Z标志位置1，否则置0.  31. XOR异或运算，当两个结果存在不同的时候进行或运算，相同的时候保持不变。NOT,非运算。  32.test dest，src指令，与AND指令一样，对两个操作数进行按位的“与”运算，唯一不同的是不将结果保存到dest，不对操作数的内容进行修改，只修改标志位。实际操作中，一般都是test eax，eax，如果eax的值为0，则Z标志位置1.  33.各种跳转及其条件：  JMP 无条件跳转   