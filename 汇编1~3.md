﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿#汇编1.指令与数据在内存中的都是以同样的二进制流存放的，区别之处在于是从哪根总线（数据总线/控制总线）传入。  2.地址总线宽度决定CPU的 寻址能力。2的N次方个。数据总线的宽度决定了数据的传输速度。控制总线的宽度决定了控制能力。  3.核心思维：从CPU的角度去考虑问题。  4.寄存器中，数据是采用的小端序存储。  5.AX=AH+AL，EAX是32位寄存器，AX是16位，AH/AL是8位  6.汇编指令不区分大小写。  7.8226H+8826H，在ax中就会变成044C（本来是1044C），多出来的1会在标志位中显示。注意对AH和AL运算时，不能越界。  8.8086的CPU内部结构为16位，只能传送16位的地址，所以寻址能力只有64K。但是其地址总线的宽度为20位，寻址能力有1M。所以采用16位段地址与16位偏移地址，经过地址加法器合并为20位的物理地址后，再进行输出。9.地址加法器的工作原理：物理地址等于段地址X16（即在末端加上个0，数据左移4位。）再加上偏移地址。  10.一个数据的X进制形式左移一位，即相当于乘上X。  11.CPU中的内存是连续的，但是人为的划分可以分成段。段地址X16可以得到基础地址，加上偏移地址得到物理地址。  12.偏移地址为16位，所以允许的一个段的长度最大为64K。   13.CPU可以通过不同的段地址与偏移地址形成一个物理地址。   14.数据在一个存储单元中，可以有两种不同的表述：如数据被存储在21F60H的存储单元中，可以表示为"数据在内存2000：1F60H。"也可以表示为"数据在内存的2000段中的1F60H元中。15.可以根据需要，将一组连续的且起始地址为16倍数的内存空间定义为一个段。  16.段寄存器就是提供段地址的，8086CPU有4个段寄存器，分别是CS（code），DS（data),SS(stack),ES(extra)。  17.一个宏观的想法：无论是程序还是数据，当其加载到内存中之后，都是一段二进制代码流。其中的一部分由控制总线传入转化成命令，其中的一部由数据总线传入转化成十六进制数据。  18.CS与IP，为8086CPU最重要的两个寄存器，指示了CPU当前要读取的指令的地址，CS为代码段寄存器，IP为指针寄存器。  即任意时刻，CPU将CS:IP指向的内容当作指令执行。  19.物理地址从地址总线传到内存中后，读取内存单元中存放的指令，指令通过数据总线途经输入输出控制电路，到达指令缓冲器。且读取一条指令后，IP的值会自动增加，使CPU可以读取下一条指令（根据当前读取的指令长度而加上该长度到达下一条指令位置。）。  20.能够改变CS/IP内容的指令被称为转移指令；最简单的转移指令：jmp。  jmp 段地址：偏移地址，课将CS和IP修改到指定值。同时jmp+某一合法寄存器的值可只修改IP。    21.sub，减法运算。sub ax，bx，即为ax-bx。  22.内存中字的存储：高位对应高低址位，低位对应低地址位。所以对于一个内存单元中的数，应该从下往上读取。  23.字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。  24.mov指令还可以将一个内存单元中的内容送入寄存器。mov 寄存器名，内存单元地址。[...]表示偏移地址，另外确定内存单元所需的段地址由DS决定（一致）。将寄存器中的内容送入内存单元表示为：mov [...]，寄存器名。  25.8086CPU不支持直接将数据写入段寄存器，必须先通过改变其他寄存器的值，然后寄存器与寄存器间进行操作，才能改变段寄存器的值。  指令中只写偏移地址，段地址需要在事先改变。  26.mov的用法小结：mov 寄存器，数据/mov 寄存器，寄存器/mov 寄存器，内存单元/mov 内存单元，寄存器/mov 段寄存器，寄存器/mov 寄存器，段寄存器。  27.类比代码段得到数据段的定义方法：将某为16倍数的地址作为首地址，不超过64K的长度作为数据段长度，把dx段寄存器改为首地址即可。  28.字型数据-->偏移地址差为2位。  29.现如今的CPU都有栈的设计，8086CPU提供相关指令以栈的形式访问内存，所以在基于8086CPU编程的时候，可以将一段连续的内存空间作为栈使用。  30.从程序化的角度来看，必须有一个指针指向栈最上面的元素。31.如何知道一段内存空间被当作栈来使用？如何知道接下来要操作的栈中数据哪个是在栈顶的。类似于CS:IP,8086CPU中，SS：IP始终指向栈顶。  32.栈顶指针可以指到最底层。  33.POP或者PUSH指令，在两种极端情况下都会造成栈溢出。  34.栈是一种可以被特殊访问的内存空间。  35.PUSH指令和POP指令，可以在内存与寄存器之间传递数据，也可以在寄存器与寄存器之间，内存与内存之间传递数据。由于栈中的操作对象（栈顶指针所指向的字型数据确定，所以在指令中只需写偏移指令或者寄存器名称。  36.栈顶清零不能用MOV AX,0。要用SUB AX,AX。37.将10000H~1000FH的空间当作栈的初始化汇编代码：  mov ax,10000H  mov ss,ax  mov sp,0010Hss是段寄存器，不能被直接赋值。注意后面栈顶指针的指向，实际上已经超出了栈的范围，在栈底的下面一位更高地址。  38.push ax是入栈指令，它将在栈顶之上压入新的数据。一定要注意其执行过程是：先将记录栈顶偏移地址的SP减2，使得SS：SP指向新的内存单元，然后再将数据写入内存单元中。  39.我们要十分清楚的是：push和pop指令与mov指令不同，CPU执行mov指令只需一步操作，即传送。而执行push指令时，实际上有两步操作：先改变SP的值，后向SS:SP处传送。执行pop指令时，先读取SS:SP的数据，再改变SP的值。40.为什么栈的长度最大只有64K？与数据总线是16位有关。64X1024=2的16次方。  41.数据段没有指针，直接用偏移地址。  42.![](https://github.com/Hy0uka/Warehouse/blob/master/%E6%A0%88.png?raw=true)  